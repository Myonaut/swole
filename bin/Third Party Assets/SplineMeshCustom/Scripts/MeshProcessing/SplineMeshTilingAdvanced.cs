/* Adapted from SplineMeshTiling.cs to better fit our needs. */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Unity.VisualScripting;
using UnityEngine;
#if UNITY_EDITOR

#endif

namespace SplineMesh {
    /// <summary>
    /// Deform a mesh and place it along a spline, given various parameters.
    /// 
    /// This class intend to cover the most common situations of mesh bending. It can be used as-is in your project,
    /// or can serve as a source of inspiration to write your own procedural generator.
    /// </summary>
    [ExecuteInEditMode]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class SplineMeshTilingAdvanced : MonoBehaviour {

        private static int SortLODs(LOD a, LOD b)
        {
            Debug.Log(a.screenRelativeTransitionHeight + " vs " + b.screenRelativeTransitionHeight);
            if (a.screenRelativeTransitionHeight < b.screenRelativeTransitionHeight) return 1;
            if (a.screenRelativeTransitionHeight > b.screenRelativeTransitionHeight) return -1;
            return 0;
        }

        public bool regenerate;

        public bool combineMeshes = true;

        private GameObject generated;
        private Spline spline = null;
        private bool toUpdate = false;

        [Serializable]
        public struct MeshLOD
        {
            public float screenRelativeTransitionHeight;
            public Mesh mesh;
        }

        [Serializable]
        public class SpawnableMesh
        {
            [Range(0f, 1f)]
            public float spawnChance;

            [Tooltip("Mesh to bend along the spline.")]
            public List<MeshLOD> meshes;
            [Tooltip("Material to apply on the bent mesh.")]
            public Material material;
            [Tooltip("Physic material to apply on the bent mesh.")]
            public PhysicMaterial physicMaterial;
            [Tooltip("Translation to apply on the mesh before bending it.")]
            public Vector3 translation;
            [Tooltip("Rotation to apply on the mesh before bending it.")]
            public Vector3 rotation;
            [Tooltip("Scale to apply on the mesh before bending it.")]
            public Vector3 scale = Vector3.one;

            [Tooltip("If true, a mesh collider will be generated.")]
            public bool generateCollider = true;

            public float finalOffset;
        }

        [Serializable]
        public class SpawnableMeshGroup
        {
            public int spawnCount = 1;
            public List<SpawnableMesh> meshPool;

            public bool IsEmpty => spawnCount <= 0 || meshPool == null || meshPool.Count <= 0;

            public SpawnableMesh GetMesh()
            {
                if (meshPool == null || meshPool.Count <= 0) return null;

                if (meshPool.Count > 1)
                {
                    for (int a = 0; a < 100; a++)
                    {
                        int i = a % meshPool.Count;
                        var mesh = meshPool[i];

                        if (UnityEngine.Random.value < mesh.spawnChance) return mesh;
                    }
                }

                return meshPool[0];
            }
        }

        [Tooltip("If true, the mesh will be bent on play mode. If false, the bent mesh will be kept from the editor mode, allowing lighting baking.")]
        public bool updateInPlayMode;

        [Header("Main Mesh Group")]
        public SpawnableMeshGroup mainGroup;
        [Range(0f, 1f)]
        public float mainStartOffset = 0f;
        [Range(0f, 1f)]
        public float mainEndOffset = 0f;

        [Header("Start Mesh Group")]
        public SpawnableMeshGroup startGroup;

        [Header("End Mesh Group")]
        public SpawnableMeshGroup endGroup;

        private void OnEnable() {
            // tip : if you name all generated content in the same way, you can easily find all of it
            // at once in the scene view, with a single search.
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

            spline = GetComponentInParent<Spline>();
            spline.NodeListChanged += (s, e) => toUpdate = true;
            if (spline.CurveChanged == null) spline.CurveChanged = new UnityEngine.Events.UnityEvent();
            spline.CurveChanged.AddListener(OnRebuildCurve);

            toUpdate = true;
        }
        private void OnDisable()
        {
            if (spline != null && spline.CurveChanged != null) spline.CurveChanged.RemoveListener(OnRebuildCurve);
        }

        private void OnRebuildCurve()
        {
            if (!combineMeshes) return;
            CreateMeshes();
        }

#if UNITY_EDITOR
        private void OnValidate() {
            if (spline == null) return;
            if (regenerate) 
            { 
                toUpdate = true;
            }
        }


        private void Update() {
            // we can prevent the generated content to be updated during playmode to preserve baked data saved in the scene
            if (!updateInPlayMode && Application.isPlaying) return;

            if (toUpdate) {
                toUpdate = false;
                CreateMeshes();
            }
        }
#endif

        public struct CombineMeshKey
        {
            public int lodIndex;
            public Material[] materials;
            public bool useCollider;
            public PhysicMaterial physicMaterial;

            public bool IsMatch(int lodIndex, Material[] materials, bool useCollider, PhysicMaterial physicMaterial)
            {
                if (this.lodIndex != lodIndex) return false;
                if (this.useCollider != useCollider) return false;
                if (this.physicMaterial != physicMaterial) return false;

                if (this.materials == null || materials == null) return false;
                if (this.materials.Length != materials.Length) return false;
                for (int a = 0; a < materials.Length; a++)
                {
                    if (materials[a] != this.materials[a]) return false;
                }

                return true;
            }
        }
        private class CombineMeshGroup
        {
            public CombineMeshKey combineKey;
            public List<CombineInstance> instances;

            public void AddInstance(CombineInstance instance) 
            {
                if (instances == null) instances = new List<CombineInstance>();
                instances.Add(instance); 
            }

            public bool IsMatch(int lodIndex, Material[] materials, bool useCollider, PhysicMaterial physicMaterial)
            {
                return combineKey.IsMatch(lodIndex, materials, useCollider, physicMaterial);
            }
        }
        private class CombineMeshGroupWithLODs
        {
            public float[] lodScreenRelativeTransitionHeights;

            public List<CombineMeshGroup> groups;

            public void AddGroup(CombineMeshGroup group)
            {
                if (groups == null) groups = new List<CombineMeshGroup>();
                groups.Add(group);
            }

            public bool IsMatch(LOD[] lods)
            {
                if (lodScreenRelativeTransitionHeights == null || lods == null) return false;

                if (lodScreenRelativeTransitionHeights.Length != lods.Length) return false;

                for(int a = 0; a < lods.Length; a++)
                {
                    var lod = lods[a];
                    var th = lodScreenRelativeTransitionHeights[a];

                    if (lod.screenRelativeTransitionHeight != th) return false;
                }

                return true;
            }
        }

        private struct ObjectWithLOD
        {
            public int lodIndex;
            public GameObject gameObject;
        }
        public void CreateMeshes()
        {
#if UNITY_EDITOR
            // we don't update if we are in prefab mode
            if (UnityEditor.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage() != null) return;
#endif
            var used = new List<GameObject>();

            float endLength = spline.Length;
            float splineLength = endLength;
            float startLength = 0f;
            bool continueFill = true;
            if (!startGroup.IsEmpty)
            {
                for(int a = 0; a < startGroup.spawnCount; a++)
                {
                    var spawnMesh = startGroup.GetMesh();
                    if (spawnMesh == null || spawnMesh.meshes == null || spawnMesh.meshes.Count <= 0) continue;
                    if (spawnMesh.scale == Vector3.zero) spawnMesh.scale = Vector3.one;

                    var go_ = FindOrCreate($"start mesh {a}", MeshBender.FillingMode.StretchToInterval, spawnMesh.meshes, spawnMesh.material, spawnMesh.physicMaterial, spawnMesh.translation, spawnMesh.rotation, spawnMesh.scale, out var sourceMesh);
                    float length = sourceMesh.Length;
                    float nextLength = Mathf.Min(startLength + length, endLength);
                    var benders = go_.GetComponentsInChildren<MeshBender>();
                    foreach (var bender in benders)
                    {
                        bender.SetInterval(spline, startLength + spawnMesh.finalOffset, nextLength + spawnMesh.finalOffset);
                        if (combineMeshes)
                        {
                            bender.SetDirty();
                            bender.ComputeIfNeeded();
                        }
                    }
                    startLength = nextLength;
                    var colliders = go_.GetComponentsInChildren<MeshCollider>();
                    foreach(var collider in colliders) collider.enabled = spawnMesh.generateCollider;
                    used.Add(go_);

                    if (nextLength >= endLength)
                    {
                        continueFill = false;
                        break;
                    }
                }

            }

            if (continueFill)
            {
                if (!endGroup.IsEmpty)
                {
                    for (int a = 0; a < endGroup.spawnCount; a++)
                    {
                        var spawnMesh = endGroup.GetMesh();
                        if (spawnMesh == null || spawnMesh.meshes == null || spawnMesh.meshes.Count <= 0) continue;
                        if (spawnMesh.scale == Vector3.zero) spawnMesh.scale = Vector3.one;

                        var go_ = FindOrCreate($"end mesh {a}", MeshBender.FillingMode.StretchToInterval, spawnMesh.meshes, spawnMesh.material, spawnMesh.physicMaterial, spawnMesh.translation, spawnMesh.rotation, spawnMesh.scale, out var sourceMesh);
                        float length = sourceMesh.Length;
                        float nextLength = Mathf.Max(endLength - length, startLength);
                        var benders = go_.GetComponentsInChildren<MeshBender>();
                        foreach (var bender in benders)
                        {
                            bender.SetInterval(spline, nextLength + spawnMesh.finalOffset, endLength + spawnMesh.finalOffset);
                            if (combineMeshes)
                            {
                                bender.SetDirty();
                                bender.ComputeIfNeeded();
                            }
                        }
                        endLength = nextLength;
                        var colliders = go_.GetComponentsInChildren<MeshCollider>();
                        foreach (var collider in colliders) collider.enabled = spawnMesh.generateCollider;
                        used.Add(go_);

                        if (nextLength <= 0f)
                        {
                            continueFill = false;
                            break;
                        }
                    }
                }
            }

            if (continueFill)
            {
                if (!mainGroup.IsEmpty)
                {
                    float mainLength = endLength - startLength;
                    startLength = startLength + Mathf.Lerp(0f, mainLength * 0.4999f, mainStartOffset);
                    endLength = endLength - Mathf.Lerp(0f, mainLength * 0.4999f, mainEndOffset); 
                    mainLength = endLength - startLength;
                    if (mainLength > 0f)
                    {
                        mainLength = mainLength / mainGroup.spawnCount;
                        for (int a = 0; a < mainGroup.spawnCount; a++)
                        {
                            var spawnMesh = mainGroup.GetMesh();
                            if (spawnMesh == null || spawnMesh.meshes == null || spawnMesh.meshes.Count <= 0) continue;
                            if (spawnMesh.scale == Vector3.zero) spawnMesh.scale = Vector3.one;

                            var go_ = FindOrCreate($"main mesh {a}", MeshBender.FillingMode.StretchToInterval, spawnMesh.meshes, spawnMesh.material, spawnMesh.physicMaterial, spawnMesh.translation, spawnMesh.rotation, spawnMesh.scale, out var sourceMesh);
                            float nextLength = Mathf.Min(startLength + mainLength, endLength);
                            var benders = go_.GetComponentsInChildren<MeshBender>();
                            foreach (var bender in benders)
                            {
                                bender.SetInterval(spline, startLength + spawnMesh.finalOffset, nextLength + spawnMesh.finalOffset);
                                if (combineMeshes)
                                {
                                    bender.SetDirty();
                                    bender.ComputeIfNeeded();
                                }
                            }
                            startLength = nextLength;
                            var colliders = go_.GetComponentsInChildren<MeshCollider>();
                            foreach (var collider in colliders) collider.enabled = spawnMesh.generateCollider;
                            used.Add(go_);

                            if (nextLength >= endLength)
                            {
                                continueFill = false;
                                break;
                            }
                        }
                    }
                }
            }

            if (combineMeshes)
            {
                List<GameObject> finalObjs = new List<GameObject>();
                List<CombineMeshGroupWithLODs> combineLodGroups = new List<CombineMeshGroupWithLODs>();
                List<ObjectWithLOD> tempObjects = new List<ObjectWithLOD>();

                LOD[] defaultLODs = new LOD[] { new LOD(0.01f, null) };
                var rootMatrix = generated.transform.worldToLocalMatrix;
                foreach (var obj in used)
                {
                    var lodGroup = obj.GetComponent<LODGroup>();

                    LOD[] lods = defaultLODs;
                    tempObjects.Clear();
                    if (lodGroup == null) 
                    {
                        tempObjects.Add(new ObjectWithLOD()
                        {
                            lodIndex = 0,
                            gameObject = obj
                        }); 
                    } 
                    else
                    {
                        if (lodGroup.lodCount > 0)
                        {
                            lods = lodGroup.GetLODs();
                            for(int a = 0; a < lods.Length; a++)
                            {
                                var lod = lods[a];
                                foreach(var renderer in lod.renderers)
                                {
                                    if (renderer == null) continue;
                                    tempObjects.Add(new ObjectWithLOD()
                                    {
                                        lodIndex = a,
                                        gameObject = renderer.gameObject
                                    });
                                }
                            }
                        }
                    }

                    CombineMeshGroupWithLODs combineLodGroup = null;
                    foreach (var group in combineLodGroups)
                    {
                        if (!group.IsMatch(lods)) continue;

                        combineLodGroup = group;
                        break;
                    }

                    if (combineLodGroup == null)
                    {
                        var transitionHeights = new float[lods.Length];
                        for(int b = 0; b < lods.Length; b++)
                        {
                            transitionHeights[b] = lods[b].screenRelativeTransitionHeight;
                        }
                        combineLodGroup = new CombineMeshGroupWithLODs()
                        {
                            lodScreenRelativeTransitionHeights = transitionHeights
                        };
                        combineLodGroups.Add(combineLodGroup);
                    }

                    foreach (var lodObj in tempObjects)
                    {
                        var renderingObj = lodObj.gameObject;

                        var filter = renderingObj.GetComponent<MeshFilter>();
                        if (filter == null || filter.sharedMesh == null) continue;

                        var renderer = renderingObj.GetComponent<MeshRenderer>();
                        if (renderer == null) continue;

                        var mats = renderer.sharedMaterials;
                        if (mats == null || mats.Length <= 0) continue;

                        var collider = renderingObj.GetComponent<MeshCollider>();
                        bool useCollider = collider != null && collider.enabled;
                        PhysicMaterial physicMaterial = collider.sharedMaterial;

                        CombineMeshGroup combineGroup = null;
                        if (combineLodGroup.groups != null)
                        {
                            foreach (var group in combineLodGroup.groups)
                            {
                                if (!group.IsMatch(lodObj.lodIndex, mats, useCollider, physicMaterial)) continue;

                                combineGroup = group;
                                break;
                            }
                        }

                        if (combineGroup == null)
                        {
                            combineGroup = new CombineMeshGroup()
                            {
                                combineKey = new CombineMeshKey()
                                {
                                    lodIndex = lodObj.lodIndex,
                                    materials = mats,
                                    useCollider = useCollider,
                                    physicMaterial = physicMaterial
                                },
                            };

                            combineLodGroup.AddGroup(combineGroup);
                        }
                        
                        combineGroup.AddInstance(new CombineInstance()
                        {
                            mesh = filter.sharedMesh,
                            transform = rootMatrix * filter.transform.localToWorldMatrix
                        });
                    }
                }

                for(int r = 0; r < combineLodGroups.Count; r++)
                {
                    var renderGroup = combineLodGroups[r];
                    if (renderGroup.groups == null) continue;

                    string groupName = $"render group {r}";
                    var groupObj = FindOrCreate(groupName, true, generated.transform);
                    groupObj.transform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
                    groupObj.transform.localScale = Vector3.one;

                    var lodGroup = groupObj.GetComponent<LODGroup>();
                    Dictionary<int, List<Renderer>> lodRenderers = new Dictionary<int, List<Renderer>>();

                    int i = 0;
                    foreach (var group in renderGroup.groups)
                    {
                        if (group.instances == null || group.instances.Count <= 0) continue;

                        Mesh combinedMesh = new Mesh();
                        combinedMesh.CombineMeshes(group.instances.ToArray());
                        combinedMesh.name = $"mesh group {i}";
                        combinedMesh.RecalculateBounds();

                        var obj = FindOrCreate(combinedMesh.name, false, groupObj.transform);
                        obj.transform.localPosition = Vector3.zero;
                        obj.transform.localRotation = Quaternion.identity;
                        obj.transform.localScale = Vector3.one;

                        var filter = obj.GetComponent<MeshFilter>();
                        var renderer = obj.GetComponent<MeshRenderer>();
                        var collider = obj.GetComponent<MeshCollider>();

                        if (collider != null)
                        {
                            collider.sharedMesh = combinedMesh;
                            collider.enabled = group.combineKey.useCollider;
                        }

                        filter.sharedMesh = combinedMesh;
                        renderer.sharedMaterials = group.combineKey.materials;
                        renderer.enabled = true;

                        obj.SetActive(true);

                        if (!lodRenderers.TryGetValue(group.combineKey.lodIndex, out var renderers))
                        {
                            renderers = new List<Renderer>();
                            lodRenderers[group.combineKey.lodIndex] = renderers; 
                        }
                        renderers.Add(renderer);

                        i++;
                    }

                    List<LOD> lodsList = new List<LOD>();
                    foreach (var lodEntry in lodRenderers)
                    {
                        if (lodEntry.Value == null || lodEntry.Value.Count <= 0) continue;
                        lodsList.Add(new LOD(Mathf.Clamp01(renderGroup.lodScreenRelativeTransitionHeights[lodEntry.Key]), lodEntry.Value.ToArray()));
                    }
                    lodsList.Sort(SortLODs);
                    lodGroup.SetLODs(lodsList.ToArray());

                    groupObj.SetActive(true);
                    finalObjs.Add(groupObj);
                }

                used.Clear();
                used.AddRange(finalObjs);
            }

            int usedCount = used.Count;
            for(int u = 0; u < usedCount; u++)
            {
                var usedObj = used[u];

                var lodGroup = usedObj.GetComponent<LODGroup>();
                if (lodGroup != null)
                {
                    var lods_ = lodGroup.GetLODs();
                    foreach (var lod in lods_)
                    {
                        if (lod.renderers != null)
                        {
                            foreach (var renderer in lod.renderers)
                            {
                                if (renderer == null) continue;
                                used.Add(renderer.gameObject);
                            }
                        }
                    }
                }
            }  

            var temp = generated.transform.GetComponentsInChildren<Transform>(true); 
            bool IsValid(GameObject child)
            {
                return used.Contains(child);
            }
            foreach(var child in temp)
            {
                if (child == null) continue;

                if (child.gameObject == generated || IsValid(child.gameObject)) continue; 
                //Debug.Log("Destroying unused generated object: " + child.gameObject.name);
                UOUtility.Destroy(child.gameObject); 
            }
        }

        private GameObject FindOrCreate(string name, bool withLODs, Transform parent = null)
        {
            if (parent == null) parent = generated.transform; 

            var childTransform = parent.Find(name);
            GameObject res;
            if (childTransform == null)
            {
                if (withLODs)
                {
                    res = UOUtility.Create(name,
                        parent.gameObject,
                        typeof(LODGroup));
                }
                else
                {
                    res = UOUtility.Create(name,
                        parent.gameObject,
                        typeof(MeshFilter),
                        typeof(MeshRenderer),
                        typeof(MeshBender),
                        typeof(MeshCollider));
                }

                res.isStatic = !updateInPlayMode;
            }
            else
            {
                res = childTransform.gameObject;
            }

            return res;
        }
        private GameObject FindOrCreate(string name, MeshBender.FillingMode fillingMode, List<MeshLOD> meshes, Material material, PhysicMaterial physicMaterial, Vector3 translation, Vector3 rotation, Vector3 scale, out SourceMesh sourceMesh)
        {
            sourceMesh = default;

            GameObject root = FindOrCreate(name, true, generated.transform);
            var lodGroup = root.GetComponent<LODGroup>();

            Dictionary<float, List<Renderer>> lods = new Dictionary<float, List<Renderer>>();
            float highestTransition = float.MinValue;
            int i = 0;
            foreach (var mesh in meshes)
            {
                var res = FindOrCreate($"lod mesh {i}", false, root.transform);

                var meshRenderer = res.GetComponent<MeshRenderer>();
                meshRenderer.material = material;
                res.GetComponent<MeshCollider>().material = physicMaterial;
                MeshBender mb = res.GetComponent<MeshBender>();
                mb.AlwaysSetFilterMesh = true;
                mb.Source = SourceMesh.Build(mesh.mesh)
                    .Translate(translation)
                    .Rotate(Quaternion.Euler(rotation))
                    .Scale(scale);
                if (mesh.screenRelativeTransitionHeight >= highestTransition) // for selecting highest detail mesh as source
                {
                    highestTransition = mesh.screenRelativeTransitionHeight;
                    sourceMesh = mb.Source;
                }
                mb.Mode = fillingMode;

                if (!lods.TryGetValue(mesh.screenRelativeTransitionHeight, out var renderers))
                {
                    renderers = new List<Renderer>();
                    lods[mesh.screenRelativeTransitionHeight] = renderers;
                }
                renderers.Add(meshRenderer);

                i++;
            }

            List<LOD> lodsList = new List<LOD>();
            foreach(var entry in lods)
            {
                lodsList.Add(new LOD(Mathf.Clamp01(entry.Key / 100f), entry.Value.ToArray()));
            }
            lodsList.Sort(SortLODs);
            lodGroup.SetLODs(lodsList.ToArray());

            return root;
        }
    }
}
